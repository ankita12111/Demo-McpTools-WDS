import { pool } from "./db.js"; // your db.ts

export async function handleToolCall(prompt: string) {
  console.log("handleToolCall received:", prompt);

  const lowerPrompt = prompt.toLowerCase();

  // Example: Match prompts about customers
  if (lowerPrompt.includes("show all customers") || lowerPrompt.includes("list customers")) {
    let client;
    try {
      client = await pool.connect();

      // Query your customers table
      const result = await client.query<{ name: string; email: string }>(
        "SELECT name, email FROM customers ORDER BY customer_id",
      );

      if (result.rows.length === 0) {
        return "No customers found in the database.";
      }

      // Format the result nicely
      const formatted = result.rows
        .map((row, i) => `${i + 1}. ${row.name} (${row.email})`)
        .join("\n");

      return `Customer List:\n${formatted}`;
    } catch (err) {
      console.error("DB Error in handleToolCall:", err);
      return "Failed to fetch customer data.";
    } finally {
      client?.release();
    }
  }

  // If no tool matches, return null so LLM is called
  return null;
}

type ValidationResult =
  | { ok: true; sql: string }
  | { ok: false; reason: string };

const ALLOWED_TABLES = new Set([
  "branches",
  "customers",
  "accounts",
  "loans",
  "transactions",
]);
const BLOCKED_KEYWORDS =
  /\b(insert|update|delete|drop|alter|truncate|create|grant|revoke|comment|copy|call|do|vacuum|analyze)\b/i;

function stripCodeFences(text: string) {
  return text.replace(/```sql/gi, "").replace(/```/g, "").trim();
}

function normalizeSql(text: string) {
  return stripCodeFences(text).replace(/\s+/g, " ").trim();
}

function normalizeTableName(sql: string) {
  // Common model mistake: using singular "customer" instead of actual table "customers".
  return sql.replace(/\b(from|join)\s+"?customer"?\b/gi, "$1 customers");
}

function normalizeIdentifier(identifier: string) {
  const parts = identifier.split(".");
  const last = parts[parts.length - 1] || identifier;
  return last.replace(/"/g, "").toLowerCase();
}

function validateGeneratedSelect(rawSql: string): ValidationResult {
  const sql = normalizeTableName(normalizeSql(rawSql));
  if (!sql) {
    return { ok: false, reason: "Empty SQL generated by model." };
  }

  const statements = sql
    .split(";")
    .map((s) => s.trim())
    .filter(Boolean);
  if (statements.length !== 1) {
    return { ok: false, reason: "Only one SQL statement is allowed." };
  }

  const single = statements[0];
  if (!/^select\b/i.test(single)) {
    return { ok: false, reason: "Only SELECT queries are allowed." };
  }

  if (BLOCKED_KEYWORDS.test(single)) {
    return { ok: false, reason: "Blocked SQL keyword detected." };
  }

  const tableRegex = /\b(?:from|join)\s+([a-zA-Z_"][\w."]*)/gi;
  const tables: string[] = [];
  let match: RegExpExecArray | null;
  while ((match = tableRegex.exec(single)) !== null) {
    tables.push(normalizeIdentifier(match[1]));
  }

  if (tables.length === 0) {
    return { ok: false, reason: "No table found in SELECT query." };
  }

  const invalidTable = tables.find((t) => !ALLOWED_TABLES.has(t));
  if (invalidTable) {
    return {
      ok: false,
      reason: `Query references disallowed table: ${invalidTable}`,
    };
  }

  return { ok: true, sql: `${single};` };
}

export async function handleToolCall2(generatedSql: string) {
  console.log("handleToolCall2 received:", generatedSql);

  const validation = validateGeneratedSelect(generatedSql);
  if (!validation.ok) {
    return `Rejected SQL: ${validation.reason}`;
  }

  let client;
  try {
    client = await pool.connect();

    // Run inside a read-only transaction with timeout as a safety boundary.
    await client.query("BEGIN");
    await client.query("SET TRANSACTION READ ONLY");
    await client.query("SET LOCAL statement_timeout = '5s'");

    const result = await client.query(validation.sql);
    await client.query("ROLLBACK");

    return JSON.stringify(
      {
        query: validation.sql,
        rowCount: result.rowCount,
        rows: result.rows,
      },
      null,
      2,
    );
  } catch (err) {
    try {
      await client?.query("ROLLBACK");
    } catch {
      // Ignore rollback failures; original error is more important.
    }
    console.error("DB Error in handleToolCall2:", err);
    return "Failed to execute generated SQL safely.";
  } finally {
    client?.release();
  }
}
